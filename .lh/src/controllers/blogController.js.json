{
    "sourceFile": "src/controllers/blogController.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 6,
            "patches": [
                {
                    "date": 1762366625514,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1762367060786,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,22 +1,20 @@\n // controllers/blogController.js\n const fs = require(\"fs\");\n-const path = require(\"path\");\n const { v2: cloudinary } = require(\"cloudinary\");\n \n const Blog = require(\"../models/Blog\");\n const { SECTION_VALUES } = require(\"../models/Blog\");\n \n-// --- Cloudinary init (uses your existing .env) ---\n+// Cloudinary\n cloudinary.config({\n   cloud_name: process.env.CLOUDINARY_CLOUD_NAME,\n   api_key:    process.env.CLOUDINARY_API_KEY,\n   api_secret: process.env.CLOUDINARY_API_SECRET,\n });\n \n-// --- small helper: keep only allowed section values ---\n+// helper: normalize & validate sections\n function cleanSections(raw) {\n-  // raw can be JSON string, array, or undefined\n   let arr = [];\n   if (typeof raw === \"string\") {\n     try { arr = JSON.parse(raw); } catch { arr = []; }\n   } else if (Array.isArray(raw)) {\n@@ -25,22 +23,23 @@\n   const allowed = new Set(SECTION_VALUES);\n   return [...new Set((arr || []).filter(v => allowed.has(v)))];\n }\n \n-// GET /api/blogs  (optionally filter by ?section= & limit= & published=)\n+// ---------- PUBLIC ----------\n exports.getBlogs = async (req, res) => {\n   try {\n-    const { section, limit, published } = req.query;\n+    const { section, category, limit, published } = req.query;\n \n     const q = {};\n     if (section) q.sections = section;\n     if (typeof published !== \"undefined\") q.published = published === \"true\";\n+    // if you later pass category slug, join against Category; for now we skip\n \n     const cursor = Blog.find(q)\n       .populate(\"category\", \"name slug\")\n       .sort({ createdAt: -1 });\n \n-    if (limit) cursor.limit(Number(limit));\n+    if (limit) cursor.limit(Math.min(Number(limit) || 0, 50));\n \n     const rows = await cursor.lean();\n     res.json(rows);\n   } catch (err) {\n@@ -48,24 +47,34 @@\n     res.status(500).json({ error: \"Server error\" });\n   }\n };\n \n-// GET /api/blogs/:slug\n exports.getBlogBySlug = async (req, res) => {\n   try {\n     const row = await Blog.findOne({ slug: req.params.slug })\n       .populate(\"category\", \"name slug\")\n       .lean();\n-\n     if (!row) return res.status(404).json({ error: \"Not found\" });\n     res.json(row);\n   } catch (err) {\n     console.error(\"getBlogBySlug error\", err);\n     res.status(500).json({ error: \"Server error\" });\n   }\n };\n \n-// POST /api/blogs  (auth + upload.single('mainImage'))\n+// ✅ NEW: return allowed homepage section tags for admin dropdowns\n+exports.getSectionOptions = async (_req, res) => {\n+  const labelMap = {\n+    top_new: \"Top New\",\n+    most_popular: \"Most Popular\",\n+    editors_pick: \"Editor Pick's\",\n+    latest_posts: \"Latest Posts\",\n+    highlights: \"Highlights\",\n+  };\n+  res.json(SECTION_VALUES.map(v => ({ value: v, label: labelMap[v] || v })));\n+};\n+\n+// ---------- ADMIN ----------\n exports.createBlog = async (req, res) => {\n   try {\n     const {\n       title,\n@@ -74,9 +83,9 @@\n       contentHtml,\n       metaTitle,\n       metaDescription,\n       published,\n-      sections, // JSON string from form\n+      sections,\n     } = req.body;\n \n     if (!title || !postedBy || !categoryId || !contentHtml) {\n       return res.status(400).json({ error: \"Missing required fields\" });\n@@ -84,15 +93,12 @@\n     if (!req.file) {\n       return res.status(400).json({ error: \"mainImage file is required\" });\n     }\n \n-    // upload main image to Cloudinary\n-    const result = await cloudinary.uploader.upload(req.file.path, {\n+    const upload = await cloudinary.uploader.upload(req.file.path, {\n       folder: \"blog-main-images\",\n       overwrite: true,\n     });\n-\n-    // clean up local temp file\n     try { fs.unlinkSync(req.file.path); } catch {}\n \n     const doc = await Blog.create({\n       title,\n@@ -100,15 +106,11 @@\n       category: categoryId,\n       contentHtml,\n       metaTitle,\n       metaDescription,\n-      published: published !== \"false\", // default true unless explicitly \"false\"\n+      published: published !== \"false\",\n       sections: cleanSections(sections),\n-\n-      mainImage: {\n-        url: result.secure_url,\n-        public_id: result.public_id,\n-      },\n+      mainImage: { url: upload.secure_url, public_id: upload.public_id },\n     });\n \n     res.status(201).json(doc);\n   } catch (err) {\n@@ -116,61 +118,40 @@\n     res.status(500).json({ error: \"Server error\" });\n   }\n };\n \n-// PUT /api/blogs/:id  (auth + upload.single('mainImage'))\n exports.updateBlog = async (req, res) => {\n   try {\n     const { id } = req.params;\n \n-    // fields allowed to update\n     const set = {};\n-    const fields = [\n-      \"title\",\n-      \"postedBy\",\n-      \"contentHtml\",\n-      \"metaTitle\",\n-      \"metaDescription\",\n-    ];\n+    const fields = [\"title\", \"postedBy\", \"contentHtml\", \"metaTitle\", \"metaDescription\"];\n     fields.forEach((f) => {\n       if (typeof req.body[f] !== \"undefined\") set[f] = req.body[f];\n     });\n+    if (typeof req.body.categoryId !== \"undefined\") set.category = req.body.categoryId;\n+    if (typeof req.body.published !== \"undefined\") set.published = req.body.published === \"true\";\n+    if (typeof req.body.sections !== \"undefined\") set.sections = cleanSections(req.body.sections);\n \n-    if (typeof req.body.categoryId !== \"undefined\") {\n-      set.category = req.body.categoryId;\n-    }\n-    if (typeof req.body.published !== \"undefined\") {\n-      set.published = req.body.published === \"true\";\n-    }\n-    if (typeof req.body.sections !== \"undefined\") {\n-      set.sections = cleanSections(req.body.sections);\n-    }\n-\n-    // if a new main image was uploaded, replace on Cloudinary\n     if (req.file) {\n       const current = await Blog.findById(id).select(\"mainImage.public_id\");\n       if (!current) return res.status(404).json({ error: \"Not found\" });\n-\n-      // delete old if present\n       if (current.mainImage?.public_id) {\n         try { await cloudinary.uploader.destroy(current.mainImage.public_id); } catch {}\n       }\n-\n       const up = await cloudinary.uploader.upload(req.file.path, {\n         folder: \"blog-main-images\",\n         overwrite: true,\n       });\n       try { fs.unlinkSync(req.file.path); } catch {}\n-\n       set.mainImage = { url: up.secure_url, public_id: up.public_id };\n     }\n \n     const updated = await Blog.findByIdAndUpdate(\n       id,\n       { $set: set },\n-      { new: true, runValidators: true } // <- keep enum validation for sections\n-    )\n-      .populate(\"category\", \"name slug\");\n+      { new: true, runValidators: true }\n+    ).populate(\"category\", \"name slug\");\n \n     if (!updated) return res.status(404).json({ error: \"Not found\" });\n     res.json(updated);\n   } catch (err) {\n@@ -178,20 +159,17 @@\n     res.status(500).json({ error: \"Server error\" });\n   }\n };\n \n-// DELETE /api/blogs/:id\n exports.deleteBlog = async (req, res) => {\n   try {\n     const { id } = req.params;\n     const row = await Blog.findById(id).select(\"mainImage.public_id\");\n     if (!row) return res.status(404).json({ error: \"Not found\" });\n \n-    // best-effort delete from Cloudinary\n     if (row.mainImage?.public_id) {\n       try { await cloudinary.uploader.destroy(row.mainImage.public_id); } catch {}\n     }\n-\n     await Blog.findByIdAndDelete(id);\n     res.json({ ok: true });\n   } catch (err) {\n     console.error(\"deleteBlog error\", err);\n"
                },
                {
                    "date": 1762368660961,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,19 +1,19 @@\n // controllers/blogController.js\n-const fs = require(\"fs\");\n const { v2: cloudinary } = require(\"cloudinary\");\n+const streamifier = require(\"streamifier\");\n \n const Blog = require(\"../models/Blog\");\n const { SECTION_VALUES } = require(\"../models/Blog\");\n \n-// Cloudinary\n+// Cloudinary config\n cloudinary.config({\n   cloud_name: process.env.CLOUDINARY_CLOUD_NAME,\n   api_key:    process.env.CLOUDINARY_API_KEY,\n   api_secret: process.env.CLOUDINARY_API_SECRET,\n });\n \n-// helper: normalize & validate sections\n+// ---- helpers ----\n function cleanSections(raw) {\n   let arr = [];\n   if (typeof raw === \"string\") {\n     try { arr = JSON.parse(raw); } catch { arr = []; }\n@@ -23,17 +23,27 @@\n   const allowed = new Set(SECTION_VALUES);\n   return [...new Set((arr || []).filter(v => allowed.has(v)))];\n }\n \n+function uploadBufferToCloudinary(buffer, opts = {}) {\n+  return new Promise((resolve, reject) => {\n+    const stream = cloudinary.uploader.upload_stream(\n+      { folder: \"blog-main-images\", resource_type: \"image\", ...opts },\n+      (err, result) => (err ? reject(err) : resolve(result))\n+    );\n+    streamifier.createReadStream(buffer).pipe(stream);\n+  });\n+}\n+\n // ---------- PUBLIC ----------\n exports.getBlogs = async (req, res) => {\n   try {\n     const { section, category, limit, published } = req.query;\n \n     const q = {};\n     if (section) q.sections = section;\n     if (typeof published !== \"undefined\") q.published = published === \"true\";\n-    // if you later pass category slug, join against Category; for now we skip\n+    // If you later support `category` by slug, join Category here.\n \n     const cursor = Blog.find(q)\n       .populate(\"category\", \"name slug\")\n       .sort({ createdAt: -1 });\n@@ -60,16 +70,16 @@\n     res.status(500).json({ error: \"Server error\" });\n   }\n };\n \n-// ✅ NEW: return allowed homepage section tags for admin dropdowns\n+// Return allowed homepage section tags for admin dropdowns\n exports.getSectionOptions = async (_req, res) => {\n   const labelMap = {\n-    top_new: \"Top New\",\n+    top_new:      \"Top New\",\n     most_popular: \"Most Popular\",\n     editors_pick: \"Editor Pick's\",\n     latest_posts: \"Latest Posts\",\n-    highlights: \"Highlights\",\n+    highlights:   \"Highlights\",\n   };\n   res.json(SECTION_VALUES.map(v => ({ value: v, label: labelMap[v] || v })));\n };\n \n@@ -89,17 +99,14 @@\n \n     if (!title || !postedBy || !categoryId || !contentHtml) {\n       return res.status(400).json({ error: \"Missing required fields\" });\n     }\n-    if (!req.file) {\n+    if (!req.file || !req.file.buffer) {\n       return res.status(400).json({ error: \"mainImage file is required\" });\n     }\n \n-    const upload = await cloudinary.uploader.upload(req.file.path, {\n-      folder: \"blog-main-images\",\n-      overwrite: true,\n-    });\n-    try { fs.unlinkSync(req.file.path); } catch {}\n+    // Upload image from memory buffer\n+    const upload = await uploadBufferToCloudinary(req.file.buffer);\n \n     const doc = await Blog.create({\n       title,\n       postedBy,\n@@ -114,9 +121,11 @@\n \n     res.status(201).json(doc);\n   } catch (err) {\n     console.error(\"createBlog error\", err);\n-    res.status(500).json({ error: \"Server error\" });\n+    // Bubble Cloudinary error message if present\n+    const msg = err?.message || \"Server error\";\n+    res.status(err.http_code || 500).json({ error: msg });\n   }\n };\n \n exports.updateBlog = async (req, res) => {\n@@ -131,19 +140,18 @@\n     if (typeof req.body.categoryId !== \"undefined\") set.category = req.body.categoryId;\n     if (typeof req.body.published !== \"undefined\") set.published = req.body.published === \"true\";\n     if (typeof req.body.sections !== \"undefined\") set.sections = cleanSections(req.body.sections);\n \n-    if (req.file) {\n+    // If new image provided, replace on Cloudinary\n+    if (req.file && req.file.buffer) {\n       const current = await Blog.findById(id).select(\"mainImage.public_id\");\n       if (!current) return res.status(404).json({ error: \"Not found\" });\n+\n       if (current.mainImage?.public_id) {\n         try { await cloudinary.uploader.destroy(current.mainImage.public_id); } catch {}\n       }\n-      const up = await cloudinary.uploader.upload(req.file.path, {\n-        folder: \"blog-main-images\",\n-        overwrite: true,\n-      });\n-      try { fs.unlinkSync(req.file.path); } catch {}\n+\n+      const up = await uploadBufferToCloudinary(req.file.buffer);\n       set.mainImage = { url: up.secure_url, public_id: up.public_id };\n     }\n \n     const updated = await Blog.findByIdAndUpdate(\n@@ -155,9 +163,10 @@\n     if (!updated) return res.status(404).json({ error: \"Not found\" });\n     res.json(updated);\n   } catch (err) {\n     console.error(\"updateBlog error\", err);\n-    res.status(500).json({ error: \"Server error\" });\n+    const msg = err?.message || \"Server error\";\n+    res.status(err.http_code || 500).json({ error: msg });\n   }\n };\n \n exports.deleteBlog = async (req, res) => {\n"
                },
                {
                    "date": 1762543693840,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -78,8 +78,9 @@\n     most_popular: \"Most Popular\",\n     editors_pick: \"Editor Pick's\",\n     latest_posts: \"Latest Posts\",\n     highlights:   \"Highlights\",\n+    banner: \"Banner\",\n   };\n   res.json(SECTION_VALUES.map(v => ({ value: v, label: labelMap[v] || v })));\n };\n \n"
                },
                {
                    "date": 1762632633619,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -95,8 +95,9 @@\n       metaTitle,\n       metaDescription,\n       published,\n       sections,\n+      schemaMarkup, \n     } = req.body;\n \n     if (!title || !postedBy || !categoryId || !contentHtml) {\n       return res.status(400).json({ error: \"Missing required fields\" });\n"
                },
                {
                    "date": 1762632652448,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -118,8 +118,9 @@\n       metaDescription,\n       published: published !== \"false\",\n       sections: cleanSections(sections),\n       mainImage: { url: upload.secure_url, public_id: upload.public_id },\n+      schemaMarkup: typeof schemaMarkup === \"string\" ? schemaMarkup.trim() : \"\",\n     });\n \n     res.status(201).json(doc);\n   } catch (err) {\n"
                },
                {
                    "date": 1762632724622,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -135,9 +135,10 @@\n   try {\n     const { id } = req.params;\n \n     const set = {};\n-    const fields = [\"title\", \"postedBy\", \"contentHtml\", \"metaTitle\", \"metaDescription\"];\n+    // const fields = [\"title\", \"postedBy\", \"contentHtml\", \"metaTitle\", \"metaDescription\"];\n+    const fields = [\"title\", \"postedBy\", \"contentHtml\", \"metaTitle\", \"metaDescription\", \"schemaMarkup\"];\n     fields.forEach((f) => {\n       if (typeof req.body[f] !== \"undefined\") set[f] = req.body[f];\n     });\n     if (typeof req.body.categoryId !== \"undefined\") set.category = req.body.categoryId;\n"
                }
            ],
            "date": 1762366625513,
            "name": "Commit-0",
            "content": "// controllers/blogController.js\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst { v2: cloudinary } = require(\"cloudinary\");\n\nconst Blog = require(\"../models/Blog\");\nconst { SECTION_VALUES } = require(\"../models/Blog\");\n\n// --- Cloudinary init (uses your existing .env) ---\ncloudinary.config({\n  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,\n  api_key:    process.env.CLOUDINARY_API_KEY,\n  api_secret: process.env.CLOUDINARY_API_SECRET,\n});\n\n// --- small helper: keep only allowed section values ---\nfunction cleanSections(raw) {\n  // raw can be JSON string, array, or undefined\n  let arr = [];\n  if (typeof raw === \"string\") {\n    try { arr = JSON.parse(raw); } catch { arr = []; }\n  } else if (Array.isArray(raw)) {\n    arr = raw;\n  }\n  const allowed = new Set(SECTION_VALUES);\n  return [...new Set((arr || []).filter(v => allowed.has(v)))];\n}\n\n// GET /api/blogs  (optionally filter by ?section= & limit= & published=)\nexports.getBlogs = async (req, res) => {\n  try {\n    const { section, limit, published } = req.query;\n\n    const q = {};\n    if (section) q.sections = section;\n    if (typeof published !== \"undefined\") q.published = published === \"true\";\n\n    const cursor = Blog.find(q)\n      .populate(\"category\", \"name slug\")\n      .sort({ createdAt: -1 });\n\n    if (limit) cursor.limit(Number(limit));\n\n    const rows = await cursor.lean();\n    res.json(rows);\n  } catch (err) {\n    console.error(\"getBlogs error\", err);\n    res.status(500).json({ error: \"Server error\" });\n  }\n};\n\n// GET /api/blogs/:slug\nexports.getBlogBySlug = async (req, res) => {\n  try {\n    const row = await Blog.findOne({ slug: req.params.slug })\n      .populate(\"category\", \"name slug\")\n      .lean();\n\n    if (!row) return res.status(404).json({ error: \"Not found\" });\n    res.json(row);\n  } catch (err) {\n    console.error(\"getBlogBySlug error\", err);\n    res.status(500).json({ error: \"Server error\" });\n  }\n};\n\n// POST /api/blogs  (auth + upload.single('mainImage'))\nexports.createBlog = async (req, res) => {\n  try {\n    const {\n      title,\n      postedBy,\n      categoryId,\n      contentHtml,\n      metaTitle,\n      metaDescription,\n      published,\n      sections, // JSON string from form\n    } = req.body;\n\n    if (!title || !postedBy || !categoryId || !contentHtml) {\n      return res.status(400).json({ error: \"Missing required fields\" });\n    }\n    if (!req.file) {\n      return res.status(400).json({ error: \"mainImage file is required\" });\n    }\n\n    // upload main image to Cloudinary\n    const result = await cloudinary.uploader.upload(req.file.path, {\n      folder: \"blog-main-images\",\n      overwrite: true,\n    });\n\n    // clean up local temp file\n    try { fs.unlinkSync(req.file.path); } catch {}\n\n    const doc = await Blog.create({\n      title,\n      postedBy,\n      category: categoryId,\n      contentHtml,\n      metaTitle,\n      metaDescription,\n      published: published !== \"false\", // default true unless explicitly \"false\"\n      sections: cleanSections(sections),\n\n      mainImage: {\n        url: result.secure_url,\n        public_id: result.public_id,\n      },\n    });\n\n    res.status(201).json(doc);\n  } catch (err) {\n    console.error(\"createBlog error\", err);\n    res.status(500).json({ error: \"Server error\" });\n  }\n};\n\n// PUT /api/blogs/:id  (auth + upload.single('mainImage'))\nexports.updateBlog = async (req, res) => {\n  try {\n    const { id } = req.params;\n\n    // fields allowed to update\n    const set = {};\n    const fields = [\n      \"title\",\n      \"postedBy\",\n      \"contentHtml\",\n      \"metaTitle\",\n      \"metaDescription\",\n    ];\n    fields.forEach((f) => {\n      if (typeof req.body[f] !== \"undefined\") set[f] = req.body[f];\n    });\n\n    if (typeof req.body.categoryId !== \"undefined\") {\n      set.category = req.body.categoryId;\n    }\n    if (typeof req.body.published !== \"undefined\") {\n      set.published = req.body.published === \"true\";\n    }\n    if (typeof req.body.sections !== \"undefined\") {\n      set.sections = cleanSections(req.body.sections);\n    }\n\n    // if a new main image was uploaded, replace on Cloudinary\n    if (req.file) {\n      const current = await Blog.findById(id).select(\"mainImage.public_id\");\n      if (!current) return res.status(404).json({ error: \"Not found\" });\n\n      // delete old if present\n      if (current.mainImage?.public_id) {\n        try { await cloudinary.uploader.destroy(current.mainImage.public_id); } catch {}\n      }\n\n      const up = await cloudinary.uploader.upload(req.file.path, {\n        folder: \"blog-main-images\",\n        overwrite: true,\n      });\n      try { fs.unlinkSync(req.file.path); } catch {}\n\n      set.mainImage = { url: up.secure_url, public_id: up.public_id };\n    }\n\n    const updated = await Blog.findByIdAndUpdate(\n      id,\n      { $set: set },\n      { new: true, runValidators: true } // <- keep enum validation for sections\n    )\n      .populate(\"category\", \"name slug\");\n\n    if (!updated) return res.status(404).json({ error: \"Not found\" });\n    res.json(updated);\n  } catch (err) {\n    console.error(\"updateBlog error\", err);\n    res.status(500).json({ error: \"Server error\" });\n  }\n};\n\n// DELETE /api/blogs/:id\nexports.deleteBlog = async (req, res) => {\n  try {\n    const { id } = req.params;\n    const row = await Blog.findById(id).select(\"mainImage.public_id\");\n    if (!row) return res.status(404).json({ error: \"Not found\" });\n\n    // best-effort delete from Cloudinary\n    if (row.mainImage?.public_id) {\n      try { await cloudinary.uploader.destroy(row.mainImage.public_id); } catch {}\n    }\n\n    await Blog.findByIdAndDelete(id);\n    res.json({ ok: true });\n  } catch (err) {\n    console.error(\"deleteBlog error\", err);\n    res.status(500).json({ error: \"Server error\" });\n  }\n};\n"
        }
    ]
}